const fs = require('fs');
const path = require('path');

const WEDDINGS_DIR = path.resolve(__dirname, '../../mariage-content');
const OUTPUT_FILE = path.resolve(__dirname, '../../src/mariage/data.js');

// Valid extensions for media
const MEDIA_EXTS = ['.jpg', '.jpeg', '.png', '.mp4', '.webm'];

// Helper to normalize keys of the META section (Matching Portfolio Base)
const KEY_MAP = {
    'Name': 'title',
    'Subtitle': 'subtitle', // Specific to Wedding
    'Description Fr': 'description',
    'Description': 'description_en', // Optional fallback
    'Project Link': 'link'
};

function parseInfoTxt(filePath) {
    if (!fs.existsSync(filePath)) return {};

    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split(/\r?\n/);
    const data = {};

    lines.forEach(line => {
        const match = line.match(/^([^:]+):\s*(.*)$/);
        if (match) {
            const rawKey = match[1].trim();
            const value = match[2].trim();

            // Map the key if it exists in our map
            if (KEY_MAP[rawKey]) {
                const mappedKey = KEY_MAP[rawKey];
                data[mappedKey] = value;
            } else if (rawKey.toLowerCase() === 'subtitle') {
                // Fallback for direct english key usage if inconsistent
                data['subtitle'] = value;
            }
        }
    });

    return data;
}

function generateData() {
    if (!fs.existsSync(WEDDINGS_DIR)) {
        console.error(`Directory not found: ${WEDDINGS_DIR}`);
        return;
    }

    const weddingFolders = fs.readdirSync(WEDDINGS_DIR, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

    let imports = [];
    let weddingsData = [];

    weddingFolders.forEach((folder, index) => {
        const fullPath = path.join(WEDDINGS_DIR, folder);
        const info = parseInfoTxt(path.join(fullPath, 'info.txt'));

        // Scan for media (A, B, C...)
        const files = fs.readdirSync(fullPath);
        const mediaVars = [];

        // Check for A, B, C, D, E...
        const alphabet = 'ABCDEFGHIJ'.split('');

        alphabet.forEach(letter => {
            const match = files.find(f => f.toUpperCase().startsWith(letter + '.') && MEDIA_EXTS.includes(path.extname(f).toLowerCase()));
            if (match) {
                // Create Import
                const varName = `w_${index}_${letter}`;
                let relativePath = path.relative(path.dirname(OUTPUT_FILE), path.join(fullPath, match));
                relativePath = relativePath.split(path.sep).join('/');
                if (!relativePath.startsWith('.')) relativePath = './' + relativePath;

                imports.push(`import ${varName} from '${relativePath}';`);
                mediaVars.push(varName);
            }
        });

        weddingsData.push({
            id: index + 1,
            title: info.title || folder.toUpperCase(),
            subtitle: info.subtitle || "WEDDING EDIT",
            link: info.link || "",
            description: {
                fr: info.description || "",
                en: info.description_en || ""
            },
            media: mediaVars
        });
    });

    const fileContent = `
// AUTO-GENERATED BY scripts/mariage/generate-data.cjs
// DO NOT EDIT MANUALLY - UPDATE info.txt FILES IN STOCK

${imports.join('\n')}

export const weddings = ${JSON.stringify(weddingsData, null, 4).replace(/"(w_\d+_[A-Z])"/g, '$1')};
`;

    fs.writeFileSync(OUTPUT_FILE, fileContent);
    console.log(`Generated ${weddingsData.length} weddings to ${OUTPUT_FILE}`);
}

generateData();
